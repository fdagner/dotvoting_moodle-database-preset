       <div class="container">##actionsmenu##
        <div id="jsonInput" style="display: none;">  ##user##, [[json]]  </div>

           <div id="aggregateResult"></div>
  </div>

  
     <script>
        // Globale Variablen
        let criteria = [];
        let criteriaLabels = {};
        let criteriaIcons = ['üéØ'];
        let totalPoints = 10;
        let maxPerCrit = 10;

        // Hilfsfunktion um HTML-Tags zu entfernen
        function stripHtml(html) {
            const tmp = document.createElement('div');
            tmp.innerHTML = html;
            return tmp.textContent || tmp.innerText || '';
        }

        // Hilfsfunktion um HTML/Scripts aus Text zu entfernen (zus√§tzliche Sicherheit)
        function sanitizeText(text) {
            if (!text) return '';
            const tmp = document.createElement('div');
            tmp.textContent = text;
            let clean = tmp.innerHTML;
            clean = clean.replace(/<script[^>]*>.*?<\/script>/gi, '');
            clean = clean.replace(/javascript:/gi, '');
            clean = clean.replace(/on\w+\s*=/gi, '');
            return clean.trim();
        }

        // Zeige Fehlermeldung an
        function showError(message) {
            const container = document.querySelector('.container');
            container.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 80px; margin-bottom: 20px;">‚ö†Ô∏è</div>
                    <h1 style="color: #dc3545; margin-bottom: 20px;">Konfigurationsfehler</h1>
                    <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 10px; padding: 20px; margin: 20px 0; color: #856404;">
                        <strong>Fehler:</strong> ${message}
                    </div>
                    <div style="background: #f8f9fa; border-radius: 10px; padding: 20px; text-align: left; max-width: 600px; margin: 20px auto;">
                        <strong>Beispiel f√ºr korrekte Konfiguration:</strong><br>
                        <code style="background: white; padding: 10px; display: block; margin-top: 10px; border-radius: 5px; border: 1px solid #dee2e6;">
                            &lt;div id="choice_description"&gt;10, Qualit√§t, Originalit√§t, Umsetzung&lt;/div&gt;
                        </code>
                        <ul style="margin-top: 15px; color: #6c757d;">
                            <li>Erster Wert: Gesamtpunktzahl (1-100)</li>
                            <li>Weitere Werte: Kriterienbeschreibungen (kommagetrennt)</li>
                            <li>Mindestens 1 Kriterium erforderlich</li>
                        </ul>
                    </div>
                    <div style="margin-top: 30px; color: #6c757d;">
                        <strong>Aktuelle Eingabe:</strong><br>
                        <code style="background: #f8f9fa; padding: 10px; display: inline-block; margin-top: 5px; border-radius: 5px;">${document.getElementById('choice_description').textContent.trim()}</code>
                    </div>
                </div>
            `;
        }

        // Parse choice_description und initialisiere
        function parseChoiceDescription() {
            const choiceDesc = document.getElementById('choice_description').textContent.trim();
            const parts = choiceDesc.split(',').map(s => s.trim());
            
            if (parts.length < 2) {
                showError('choice_description muss mindestens 2 Werte enthalten (Gesamtpunktzahl, Kriterium1, ...)');
                return false;
            }
            
            // Erste Zahl ist die Gesamtpunktzahl - strenge Validierung
            const firstValueStr = parts[0];
            
            // Pr√ºfe ob es eine reine Zahl ist (nur Ziffern)
            if (!/^\d+$/.test(firstValueStr)) {
                showError(`Der erste Wert "${firstValueStr}" ist keine g√ºltige Zahl. Es sind nur Ziffern erlaubt (z.B. 10, 20, 15).`);
                return false;
            }
            
            const firstValue = parseInt(firstValueStr);
            if (firstValue <= 0) {
                showError(`Der erste Wert "${firstValueStr}" muss eine positive Zahl gr√∂√üer als 0 sein.`);
                return false;
            }
            
            if (firstValue > 100) {
                showError(`Der erste Wert "${firstValueStr}" ist zu gro√ü. Die Punktzahl muss zwischen 1 und 100 liegen.`);
                return false;
            }
            
            totalPoints = firstValue;
            maxPerCrit = firstValue;
            
            // Rest sind die Kriterien
            criteria = [];
            criteriaLabels = {};
            for (let i = 1; i < parts.length; i++) {
                const critId = `crit${i}`;
                criteria.push(critId);
                criteriaLabels[critId] = parts[i];
            }
            
            return true;
        }

        // Aggregation
        function aggregate() {
            let validCount = 0;
            const allKeys = new Set();
            const allData = [];
            let detectedTotalPoints = null;

            // Lese JSON-Daten aus dem div
            const jsonText = document.getElementById('jsonInput').textContent.trim();
            
            // Finde alle JSON-Objekte mit optionalem User-Platzhalter davor
            // Format: ##user##, {"json"} oder {"json"}
            const jsonMatches = [];
            const userMatches = [];
            let depth = 0;
            let currentJson = '';
            let currentUser = '';
            let beforeJson = '';
            
            for (let i = 0; i < jsonText.length; i++) {
                const char = jsonText[i];
                
       if (char === '{') {
        if (depth === 0) {
            // Nimm alles vor dem { als potenziellen User + Komma
            let potentialPrefix = beforeJson.trim();

            // Entferne optionales Komma am Ende
            if (potentialPrefix.endsWith(',')) {
                potentialPrefix = potentialPrefix.slice(0, -1).trim();
            }

            // Wenn etwas √ºbrig bleibt und es kein JSON-Fragment ist ‚Üí als Username werten
            if (potentialPrefix && !potentialPrefix.startsWith('{') && !potentialPrefix.startsWith('[')) {
                currentUser = potentialPrefix;
            } else {
                currentUser = '';
            }

            beforeJson = '';
        }
                    depth++;
                    currentJson += char;
                } else if (char === '}') {
                    currentJson += char;
                    depth--;
                    
                    if (depth === 0 && currentJson.trim() !== '') {
                        jsonMatches.push(currentJson.trim());
                        userMatches.push(currentUser);
                        currentJson = '';
                        currentUser = '';
                    }
                } else if (depth > 0) {
                    currentJson += char;
                } else {
                    beforeJson += char;
                }
            }

            if (jsonMatches.length === 0) {
                showError('Keine g√ºltigen JSON-Objekte gefunden');
                return;
            }

            // Parse alle JSON-Objekte und sammle alle Keys
            jsonMatches.forEach((jsonStr, index) => {
                try {
                    const data = JSON.parse(jsonStr);
                    allData.push(data);
                    
                    // Lese totalPoints vom ERSTEN Datensatz
                    if (index === 0 && data.hasOwnProperty('totalPoints')) {
                        detectedTotalPoints = data.totalPoints;
                    }
                    
                    // Sammle alle Keys - vom ERSTEN Objekt bestimmt die Reihenfolge
                    const keys = Object.keys(data).filter(key => 
                        !/^crit\d+$/.test(key) && 
                        key !== 'totalPoints' && 
                        !key.endsWith('_comment')
                    );
                    
                    keys.forEach(key => {
                        const cleanKey = stripHtml(key);
                        allKeys.add(cleanKey);
                    });
                    
                    validCount++;
                } catch (e) {
                    console.error(`Ung√ºltiges JSON in Objekt ${index + 1}: "${jsonStr}"`, e.message);
                }
            });

            if (allKeys.size === 0) {
                showError('Keine g√ºltigen Kriterien in den JSON-Daten gefunden');
                return;
            }

            // Setze totalPoints und maxPerCrit aus den Daten
            if (detectedTotalPoints !== null) {
                totalPoints = detectedTotalPoints;
                maxPerCrit = detectedTotalPoints;
            } else {
                // Fallback: Bestimme aus den h√∂chsten Werten
                const allValues = allData.flatMap(data => 
                    Object.entries(data)
                        .filter(([key]) => !/^crit\d+$/.test(key) && key !== 'totalPoints')
                        .map(([_, value]) => value)
                );
                if (allValues.length > 0) {
                    maxPerCrit = Math.max(...allValues, 10);
                    totalPoints = maxPerCrit;
                }
            }

            // Erstelle criteria Arrays aus den gefundenen Keys
            criteria = [];
            criteriaLabels = {};
            // Behalte die Reihenfolge wie sie erscheinen (nicht sortieren!)
            const orderedKeys = Array.from(allKeys);
            
            orderedKeys.forEach((label, index) => {
                const critId = `crit${index + 1}`;
                criteria.push(critId);
                criteriaLabels[critId] = label;
            });

            // Berechne Durchschnitte f√ºr jedes Kriterium und sammle Kommentare
            const aggregates = {};
            const comments = {};
            criteria.forEach(crit => {
                aggregates[crit] = [];
                comments[crit] = [];
            });

            allData.forEach((data, dataIndex) => {
                const username = userMatches[dataIndex];
                
                criteria.forEach(crit => {
                    const label = criteriaLabels[crit];
                    
                    // Suche nach dem Label (mit und ohne HTML)
                    let value = null;
                    let comment = null;
                    
                    // Zuerst: Exakte √úbereinstimmung
                    if (data.hasOwnProperty(label)) {
                        value = data[label];
                        comment = data[`${label}_comment`] || data[`${crit}_comment`] || null;
                    } else if (data.hasOwnProperty(crit)) {
                        value = data[crit];
                        comment = data[`${crit}_comment`] || null;
                    } else {
                        // Suche nach Key der ohne HTML dem Label entspricht
                        for (const [key, val] of Object.entries(data)) {
                            if (stripHtml(key) === label) {
                                value = val;
                                comment = data[`${key}_comment`] || null;
                                break;
                            }
                        }
                    }
                    
                 if (value !== null) {
    aggregates[crit].push(value);
    if (comment) {
        comments[crit].push(sanitizeText(comment));
    }
}
                });
            });

            const averages = {};
            criteria.forEach(crit => {
                const values = aggregates[crit];
                if (values.length > 0) {
                    const sum = values.reduce((a, b) => a + b, 0);
                    averages[crit] = sum / values.length;
                } else {
                    averages[crit] = 0;
                }
            });

            displayAggregate(averages, validCount, comments);
        }

        function displayAggregate(averages, validCount, comments) {
            const resultElem = document.getElementById('aggregateResult');
            resultElem.innerHTML = `<div class="result-title">##userpicture## ##user##</div>`;

            criteria.forEach((crit, index) => {
                const icon = criteriaIcons[index % criteriaIcons.length];
                const label = criteriaLabels[crit];
                const avg = averages[crit];
                const rounded = Math.round(avg * 10) / 10;
                const full = Math.floor(avg);
                const fractional = avg - full;
                const critComments = comments[crit] || [];

                const critDiv = document.createElement('div');
                critDiv.classList.add('agg-criterion');
                
                const labelElem = document.createElement('label');
                labelElem.textContent = `${icon} ${label}`;
                critDiv.appendChild(labelElem);

                const visualElem = document.createElement('div');
                visualElem.classList.add('agg-visual');
                
                for (let i = 1; i <= maxPerCrit; i++) {
                    const point = document.createElement('div');
                    point.classList.add('agg-point');
                    if (i <= full) {
                        point.classList.add('filled');
                    } else if (i === full + 1 && fractional >= 0.25) {
                        point.classList.add('half');
                    } else {
                        point.classList.add('empty');
                    }
                    visualElem.appendChild(point);
                }
                
                const scoreText = document.createElement('span');
                scoreText.classList.add('agg-score-text');
                scoreText.textContent = `${rounded} / ${maxPerCrit}`;
                visualElem.appendChild(scoreText);

                critDiv.appendChild(visualElem);
                
                // Kommentare hinzuf√ºgen (aufklappbar)
                if (critComments.length > 0) {
                    const commentSection = document.createElement('div');
                    commentSection.style.marginTop = '15px';
                    
                    const toggleBtn = document.createElement('button');
                    toggleBtn.type = 'button';
                    toggleBtn.textContent = `üí¨ ${critComments.length} Kommentar${critComments.length !== 1 ? 'e' : ''} anzeigen`;
                    toggleBtn.style.cssText = 'background: #e2e8f0; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.9em; color: #2d3748;';
                    toggleBtn.onclick = function() {
                        const commentList = this.nextElementSibling;
                        if (commentList.style.display === 'none') {
                            commentList.style.display = 'block';
                            this.textContent = `üí¨ ${critComments.length} Kommentar${critComments.length !== 1 ? 'e' : ''} ausblenden`;
                        } else {
                            commentList.style.display = 'none';
                            this.textContent = `üí¨ ${critComments.length} Kommentar${critComments.length !== 1 ? 'e' : ''} anzeigen`;
                        }
                    };
                    
                    const commentList = document.createElement('ul');
                    commentList.style.cssText = 'display: none; margin-top: 10px; list-style: none; padding: 0;';
                    
                    critComments.forEach((comment, idx) => {
                        const li = document.createElement('li');
                        li.style.cssText = 'background: #f7fafc; padding: 10px; margin-bottom: 5px; border-left: 3px solid #2d3748;';
                        li.textContent = `${comment}`;
                        commentList.appendChild(li);
                    });
                    
                    commentSection.appendChild(toggleBtn);
                    commentSection.appendChild(commentList);
                    critDiv.appendChild(commentSection);
                }

                resultElem.appendChild(critDiv);
            });
        }

        window.addEventListener('load', () => {
            // F√ºhre automatisch Aggregation durch beim Laden
            // Kriterien werden direkt aus JSON-Daten extrahiert
            aggregate();
        });
    </script>